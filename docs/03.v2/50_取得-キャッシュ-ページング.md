---
title: 50. 取得-キャッシュ-ページング（設計書V2）
source:
author:
  -
published:
created: 2026-01-30
description:
tags:
---

本ファイルは設計書V1（アーカイブ済み）から、投稿の取得・キャッシュ・ページングに関する章を分割したもの。

## この章で決めること

- 投稿一覧の query/caching 戦略（TanStack Query、クエリキー、キャッシュ方針）
- 無限スクロール/ページング（cursor方式）とローディング/再試行
- キャッシュ更新とスクロール位置の保存/復元

## この章の守備範囲

- 投稿一覧の「取得・キャッシュ・ページング」に関する実装設計を扱う
- URLスキーム/正規化は扱わない（URL章を参照）

## 関連ドキュメント（参照先）

- URL/状態管理: `docs/03.v2/10_URL-状態管理.md`
- ごみ箱（一覧条件/操作）: `docs/03.v2/60_ごみ箱.md`

# SPA（投稿一覧キャッシュの切替）

- モード切替、ごみ箱表示のような「同一画面内の状態切替」では、**取得済みの投稿一覧をキャッシュから即時復元**する
- キャッシュ/再検証は TanStack Query に集約する
  - `mode`/`view` をクエリキーに含め、状態切替時に「キャッシュを切り替えて表示」できるようにする
  - `tags` / `favorite` による絞り込みは **キャッシュせず毎回再取得**する（仕様書「タグ絞り込み/お気に入り絞り込み時は再取得」に合わせる）
  - 詳細は本ファイル内の「投稿データ取得・キャッシュ戦略（TanStack Query）」「投稿一覧ページング（カーソル方式）内部設計」を参照する
  - URL更新の内部フローは `docs/03.v2/10_URL-状態管理.md` の「表示切り替え 内部フロー」を参照する


# データ取得/キャッシュ

- `tags` / `favorite` による絞り込みは **キャッシュせず毎回再取得**する（仕様書方針）
- 取得 I/F は `postRepository.findMany({ mode, status, tags, favorite, limit, orderBy, cursor })`
- タグ/お気に入りの更新が発生した場合も、絞り込み中は差分更新を行わず再取得で整合を取る
- 一覧取得のキャッシュはクライアント（TanStack Query）で行い、サーバー側キャッシュは当面設けない（CDN は静的アセットのみ）


---

# 投稿一覧

## 入力（Source）
- 画面状態（URL→状態、正規化）の詳細は `docs/03.v2/10_URL-状態管理.md` を参照する
- `mode`: `memo | note`（未指定/不正値は `memo` に正規化）
- `tags`: `string[]`（URL の `tags` を `getAll()` して導出、未指定は `[]`）
- `favorite`: boolean（URL の `favorite` が truthy の場合のみ true、未指定は false）
- `limit`: 10（初期表示件数、固定）

## 投稿検索（タグ/お気に入り）

- 投稿検索 UI は「タグ絞り込み（TagFilter）」「お気に入り絞り込み（FavoriteFilter）」に加えて、「絞り込み解除（ClearFilters）」を提供する
  - 絞り込み解除は `tags` と `favorite` を URL から削除する（`view` / `mode` は維持する）
  - `tags` に表示対象外の `tagId` が含まれていても（未使用で非表示/削除/未同期等）、絞り込み解除で通常状態へ戻れる

## 表示ルール
- 一覧は1カラム（縦1列）で `createdAt` 降順に表示する
- 同一 `createdAt` の安定ソートのため、第二キーとして `postId` 降順を併用する
- 各投稿カードでは、少なくとも以下を表示する（MVP）
  - モード（メモ/ノート）
  - 作成日時（絶対時刻。表示: `YYYY-MM-DD HH:mm`、dayjsでフォーマット、ローカルタイム）
  - タグ（チップ）
  - お気に入り（スター）ボタン（通常ビューのみ）
  - 本文プレビュー（`contentText`）
  - 更新日時（MVPでは表示しない）

## 投稿データ取得・キャッシュ戦略（TanStack Query）

- 取得条件
	- `status=active` かつ `mode=<URLのmode>`（通常ビュー）
- 取得I/F
	- `postRepository.findMany({ mode, status: "active", tags, favorite, limit, orderBy: [{ createdAt: "desc" }, { postId: "desc" }], cursor })`

## クエリキー設計

  - **キャッシュ対象**
	- 表示モード（`mode=memo|note`）とビュー（通常／`view=trash`）
		- 通常一覧（キャッシュする）: `["posts", { view: "normal", mode }]`
	    - ごみ箱一覧（キャッシュする）: `["posts", { view: "trash" }]`（※mode はデータ取得条件に使わない前提なら持たなくて OK）
	  - **非キャッシュ（毎回再取得）**
		- タグ絞り込み / お気に入り絞り込み（仕様書に合わせる）
		- 絞り込み（キャッシュしない）: `["posts-filter", { view, mode, tags, favorite }]`（`gcTime: 0` + `staleTime: 0` で即時破棄し、復元用キャッシュとして保持しない）

## キャッシュ方針

  - 目的: mode/view の切替や戻る/進むで、取得済み一覧を **即時に復元**する
  - 対象/形: クエリキーは mode/view のみ（`cursor` は含めない）。キャッシュは `pages: PostDTO[][]`（描画は `pages.flat()`）
  - 追加取得: `fetchNextPage()` を使い、TanStack Query が `pages` を自動更新する
  - 更新系: 一覧に影響する操作は `setQueryData` で差分更新する
  - フィルタ: tags/favorite は毎回再取得（`["posts-filter", ...]` は `gcTime: 0` + `staleTime: 0` で保持しない）
  - 再取得/その他: `invalidateQueries` は原則使わない（差分で整合が取れない場合のみフォールバック）。即時復元優先で `staleTime` 長め + `refetchOnMount` / `refetchOnWindowFocus` / `refetchOnReconnect` 無効

## スクロール位置の保存/復元（Scroll Restoration）

TanStack Query は **データ（一覧）**の復元を担うが、SPA遷移（URLのsearchParams切替）ではブラウザがスクロール位置を自動復元しないため、スクロール位置は別途保存/復元する。

### 目的

- mode/view/tags/favorite 切替やブラウザの戻る/進むで、ユーザーが見ていた位置（スクロール位置）を **体感的に維持**する
- 一覧の復元単位（queryKey）とスクロール復元単位を一致させ、手戻りを減らす

### 対象範囲

- 対象: 投稿一覧（通常 / ごみ箱 / 絞り込み）
- 非対象: 投稿本文エディタ内のキャレット位置やエディタ内スクロール（MVP対象外）

### 保存単位（キー設計）

スクロール位置は「現在表示している一覧の queryKey 単位」で保存/復元する（= 一覧データと同じ単位）。

- 通常（キャッシュ対象）: `["posts", { view: "normal", mode }]`
- ごみ箱（キャッシュ対象）: `["posts", { view: "trash" }]`
- 絞り込み（非キャッシュだがスクロールは best-effort で復元する）: `["posts-filter", { view, mode, tags, favorite }]`

保存キー文字列は、queryKey を安定に文字列化して作る。

- `scrollKey = "mono-log:scroll:v1:" + stableStringify(queryKey)`
- `stableStringify` は **キー順を固定**して JSON 文字列化する（tags は canonical 化により昇順前提）

### 保存先

- `sessionStorage`（タブ単位で、戻る/進むと相性が良い）

### 保存タイミング

二重化して「取りこぼし」を防ぐ。

1) **最優先**: URL を変更する直前（`router.push(mergeSearchParams(...))` の直前）に `save(scrollKey, window.scrollY)`
2) 保険: `PostList` の `useEffect` cleanup で `save(currentScrollKey, window.scrollY)`
3) 保険: `pagehide` で `save(currentScrollKey, window.scrollY)`（タブを閉じる/リロード等）

scroll イベントでの頻繁な書き込みは避け、必要なら 200ms 程度で throttle して保存する（MVPでは 1) + 2) + 3) を優先）。

### 復元タイミング

スクロール復元は「一覧データが描画され、DOMの高さが確定した後」に行う。

- `useInfiniteQuery` が `success` になり、`data.pages` を描画した後に `restore(scrollKey)` を実行する
- 復元手順（例）
  - `requestAnimationFrame` を 1〜2 回待つ（レイアウト確定待ち）
  - `window.scrollTo({ top: y, behavior: "auto" })`
- 保存値が無い場合は何もしない（= 先頭のまま）

### 無限スクロール（IntersectionObserver）との干渉

復元直後に viewport が末尾付近になると sentinel が即座に交差し、`fetchNextPage()` が連続発火しやすい。

- 対策: `isRestoringScroll` の間は IntersectionObserver を無効化/無視し、復元完了後に有効化する
  - 例: `useInfiniteScrollSentinel({ disabled: isRestoringScroll })`

### 破棄/上限（肥大化対策）

`sessionStorage` の肥大化を避けるため、以下で prune する。

- 最大 20 件（LRU）
- TTL 30 分（古いものは削除）

### 実装インターフェース（案）

- `createPostsScrollKey(queryKey): string`
- `scrollStore.get(key): number | null`
- `scrollStore.set(key, y): void`
- `useScrollRestoration({ key, restoreWhen }): { isRestoringScroll: boolean }`

## キャッシュ更新

### 更新責務の集約

- キャッシュ更新は posts のキャッシュ更新モジュール（例: `updatePostsCache.ts`）に集約する。UI/コンポーネントは `queryClient.*` を呼ばない
- 目的: queryKey 選定・mode/view 跨ぎ更新・並び順の変更点を 1 か所に閉じ込める

### `setQueryData` 用の純粋関数

- `removeById(infinite, postId)`（`pages` 全体から該当投稿を除去）
- `upsertSorted(infinite, post, { limit, comparator })`（重複除去→ソート順に挿入→必要ならページ配列を整える）
- `comparator`
  - 通常一覧: `createdAt DESC, postId DESC`
  - ごみ箱: `trashedAt DESC, postId DESC`

### 更新対象キー（略記）

- 通常: `K.normal(mode)` = `["posts", { view: "normal", mode }]`
- ごみ箱: `K.trash` = `["posts", { view: "trash" }]`
- 絞り込み: `["posts-filter", { view, mode, tags, favorite }]` は「毎回再取得」のため差分更新せず、必要に応じて `removeQueries` で破棄する

### キャッシュ更新表（操作 × 属性）

| 操作         | 状態遷移                  | 更新対象                              | ルール（`setQueryData`）                                                   |
| ---------- | --------------------- | --------------------------------- | --------------------------------------------------------------------- |
| 投稿作成       | （new）→ `active`       | `K.normal(post.mode)`             | `upsertSorted`（通常 comparator）                                         |
| 投稿更新       | `active` のまま          | `K.normal(post.mode)`             | `upsertSorted`（通常 comparator）                                         |
| ごみ箱投入      | `active` → `trashed`  | `K.normal(post.mode)` / `K.trash` | 通常: `removeById`<br>ごみ箱: `upsertSorted`（trash comparator）             |
| 復元         | `trashed` → `active`  | `K.trash` / `K.normal(post.mode)` | ごみ箱: `removeById`<br>通常: `upsertSorted`（通常 comparator）                |
| 完全削除（単体）   | `trashed` → （deleted） | `K.trash`                         | ごみ箱: `removeById`（安全側で `K.normal(memo)` / `K.normal(note)` からも除去してよい） |
| 完全削除（複数選択） | `trashed` → （deleted） | `K.trash`                         | `postId` リストで一括除去（`removeById` の反復またはフィルタ）                            |
| ごみ箱を空にする   | `trashed` → （deleted） | `K.trash`                         | `pages=[]` 相当へ更新、または `removeQueries({ queryKey: K.trash })`           |

> 注意: 上記は「キャッシュが存在するキーのみ」差分更新する（未取得の view/mode は何もしない）。

## 投稿の自動取得（無限スクロール）

- 投稿一覧の末尾に sentinel を置き、表示領域に入ったら次の `limit` 件を自動的に取得開始する（詳細は「投稿一覧ページング（カーソル方式）内部設計」）
- 追加取得中は取得済みの一覧は維持し、末尾に Skeleton UI（`limit` 件分）を表示する
- 追加取得に失敗した場合も一覧は維持し、エラー通知＋再試行導線を表示する（状態維持）

## 投稿一覧ページング（カーソル方式）内部設計

### トリガー（IntersectionObserver）

- 一覧末尾に sentinel 要素を置き、表示領域に入ったら `fetchNextPage()` を実行する
- `hasNextPage === true` かつ `isFetchingNextPage === false` のときのみ `fetchNextPage()` を呼び、多重実行を防止する
- `hasNextPage === false` になったら observer を解除し、sentinel を表示しない（取得終了）

### ページング（TanStack Query）

- `useInfiniteQuery` を利用し、取得結果は `data.pages: PostDTO[][]`（1ページ=1回の取得結果 `PostDTO[]`）として保持する
  - 描画は `data.pages.flat()` を `PostDTO[]` として行う
- `pageParam` は `cursor`（投稿ID文字列）で扱う
  - 初回は `pageParam=undefined`（`cursor=undefined`）で `limit` 件を取得する
  - `queryFn({ pageParam })` は `postRepository.findMany({ ..., limit, orderBy, cursor: pageParam })` を呼ぶ
  - `getNextPageParam(lastPage)` は最終要素の ID を返し、次ページが無い場合は `undefined` を返す（`hasNextPage=false`）
- `orderBy` と cursor の前提を一致させる
  - 通常一覧: `createdAt DESC, postId DESC`（cursor は `postId`）
  - ごみ箱一覧: `trashedAt DESC, postId DESC`（cursor は `postId`）

### ローディング表示（Skeleton）

- 初回ロード/追加ロードのいずれも Skeleton を表示し、ユーザーに「取得中」を明示する
  - 初回ロード（例: `isLoading`）は Skeleton のみを表示する（一覧は未表示）
  - 追加ロード（例: `isFetchingNextPage`）は取得済み一覧は維持し、末尾に Skeleton を追加表示する
- Skeleton の表示件数は常に 1 ページ分（`limit` 件）とする

### エラーと再試行

- 追加ロードに失敗した場合は、取得済み一覧を維持したままエラー通知を表示し、再試行できる導線を提供する
  - 再試行の操作は `fetchNextPage()` を再実行する
- 初回ロードに失敗した場合は、エラー表示と再試行導線を提供する
  - 再試行の操作は `refetch()` を実行する（状態維持）

## UI責務と更新

- `ModeSwitch` はクリックで `router.push(mergeSearchParams({ mode }))` を行い URL を更新する（stateは持たない）
- `TagFilter` / `FavoriteFilter`（FavoriteFilter は shadcn/ui Toggle を使用）は検索条件を URL に反映し、再取得をトリガーする（キャッシュは保持しない）
- `ClearFilters`（投稿検索の絞り込み解除）は `tags` と `favorite` を URL から削除し、通常一覧を再取得する（`view` / `mode` は維持する）
- `PostList` は `mode` / `tags` / `favorite` 変更を検知して再取得し、ローディング/エラーは共通コンポーネントで表示する

---
